// Simplified Filter Hook for iTakecare Catalog
// Manages catalog filtering without complex dependencies

import { useState, useMemo, useCallback } from 'react';
import { Product, Brand, Category } from './types-catalog';

interface FilterState {
  search: string;
  category: string | null;
  brands: string[];
  priceRange: [number, number];
}

interface FilterHookReturn {
  filters: FilterState;
  setSearch: (search: string) => void;
  setCategory: (category: string | null) => void;
  setBrands: (brands: string[]) => void;
  setPriceRange: (range: [number, number]) => void;
  resetFilters: () => void;
  filteredProducts: Product[];
  categories: Category[];
  brands: Brand[];
  hasActiveFilters: boolean;
  resultsCount: number;
}

// Extract categories from products
const extractCategories = (products: Product[]): Category[] => {
  const categoryMap = new Map<string, number>();
  
  products.forEach(product => {
    if (product.category) {
      const count = categoryMap.get(product.category) || 0;
      categoryMap.set(product.category, count + 1);
    }
  });
  
  return Array.from(categoryMap.entries()).map(([name, count]) => ({
    name,
    translation: name, // You can add translation logic here
    count,
  }));
};

// Extract brands from products
const extractBrands = (products: Product[]): Brand[] => {
  const brandMap = new Map<string, number>();
  
  products.forEach(product => {
    if (product.brand) {
      const count = brandMap.get(product.brand) || 0;
      brandMap.set(product.brand, count + 1);
    }
  });
  
  return Array.from(brandMap.entries()).map(([name, count]) => ({
    name,
    count,
  }));
};

// Get price range from products
const getPriceRange = (products: Product[]): [number, number] => {
  let minPrice = Infinity;
  let maxPrice = -Infinity;
  
  products.forEach(product => {
    const price = product.monthly_price || product.price || 0;
    if (price > 0) {
      minPrice = Math.min(minPrice, price);
      maxPrice = Math.max(maxPrice, price);
    }
  });
  
  if (minPrice === Infinity) return [0, 1000];
  
  // Round to nice numbers
  const min = Math.floor(minPrice / 10) * 10;
  const max = Math.ceil(maxPrice / 10) * 10;
  
  return [min, max];
};

// Filter products based on current filters
const filterProducts = (products: Product[], filters: FilterState): Product[] => {
  return products.filter(product => {
    // Search filter
    if (filters.search) {
      const searchTerm = filters.search.toLowerCase();
      const matchesName = product.name?.toLowerCase().includes(searchTerm);
      const matchesBrand = product.brand?.toLowerCase().includes(searchTerm);
      const matchesCategory = product.category?.toLowerCase().includes(searchTerm);
      
      if (!matchesName && !matchesBrand && !matchesCategory) {
        return false;
      }
    }
    
    // Category filter
    if (filters.category && product.category !== filters.category) {
      return false;
    }
    
    // Brand filter
    if (filters.brands.length > 0 && !filters.brands.includes(product.brand || '')) {
      return false;
    }
    
    // Price range filter
    const productPrice = product.monthly_price || product.price || 0;
    if (productPrice > 0) {
      const [minPrice, maxPrice] = filters.priceRange;
      if (productPrice < minPrice || productPrice > maxPrice) {
        return false;
      }
    }
    
    return true;
  });
};

export const usePublicSimplifiedFilter = (products: Product[]): FilterHookReturn => {
  const [filters, setFilters] = useState<FilterState>({
    search: '',
    category: null,
    brands: [],
    priceRange: [0, 1000],
  });

  // Initialize price range based on products
  const defaultPriceRange = useMemo(() => {
    return getPriceRange(products);
  }, [products]);

  // Update price range when products change
  React.useEffect(() => {
    const [min, max] = defaultPriceRange;
    setFilters(prev => ({
      ...prev,
      priceRange: [min, max],
    }));
  }, [defaultPriceRange]);

  // Extract categories and brands
  const { categories, brands } = useMemo(() => {
    return {
      categories: extractCategories(products),
      brands: extractBrands(products),
    };
  }, [products]);

  // Filter products
  const filteredProducts = useMemo(() => {
    return filterProducts(products, filters);
  }, [products, filters]);

  // Filter actions
  const setSearch = useCallback((search: string) => {
    setFilters(prev => ({ ...prev, search }));
  }, []);

  const setCategory = useCallback((category: string | null) => {
    setFilters(prev => ({ ...prev, category }));
  }, []);

  const setBrands = useCallback((brands: string[]) => {
    setFilters(prev => ({ ...prev, brands }));
  }, []);

  const setPriceRange = useCallback((priceRange: [number, number]) => {
    setFilters(prev => ({ ...prev, priceRange }));
  }, []);

  const resetFilters = useCallback(() => {
    setFilters({
      search: '',
      category: null,
      brands: [],
      priceRange: defaultPriceRange,
    });
  }, [defaultPriceRange]);

  // Check if any filters are active
  const hasActiveFilters = useMemo(() => {
    const [defaultMin, defaultMax] = defaultPriceRange;
    return !!(
      filters.search ||
      filters.category ||
      filters.brands.length > 0 ||
      filters.priceRange[0] !== defaultMin ||
      filters.priceRange[1] !== defaultMax
    );
  }, [filters, defaultPriceRange]);

  return {
    filters,
    setSearch,
    setCategory,
    setBrands,
    setPriceRange,
    resetFilters,
    filteredProducts,
    categories,
    brands,
    hasActiveFilters,
    resultsCount: filteredProducts.length,
  };
};